##### 复制

- 主备基本原理

  - M-S结构

    M-S结构，有一个主节点A和备节点B，在状态1时客户端的读写直接访问A节点，节点B是A的备库，只将A的更新都同步过来，到本地执行，以保持B与A数据相同。当需要切换的时候，就会从状态1切换到状态2，这时候客户端读写B节点，A是B的备库。在状态1时，一般将备库B设置为只读模式，理由如下:

    1.运营类的查询语句会被放到B上查询，只读模式可以防止误操作；2.防止切换时的逻辑bug，例如切换过程中的双写，导致主备不一致；3.可以利用readonly状态，来判断节点的角色。

  <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\主备切换.png" style="zoom:50%;" />

  - 主从复制流程

    主库A接收到客户端更新请求后，执行内部事务更新逻辑，同时写binlog，备库B与主库A之间维持一个长连接，主库A会为B库开启一个专用服务线程dump_tread。
  
    - 初始创建主备关系(备节点指定读取位置)
  
      事务完整同步过程:
  
      1.在B执行change master命令，设置主库A的IP、端口、用户名、密码以及开始位置(文件名和日志偏移量)。2.在B执行start slave命令，B启动两个线程，io_thread和sql_thread，其中io_thread负责与A建立连接。3. A校验完用户名、密码后，开始按照B传过来的位置，从本地读取binlog，发给B。4.备库拿到binlog后，写到本地文件，称为中转日志(relay log)。5. sql_thread读取中转日志，解析出日志里的命令，并执行。
  
    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\复制流程.png" style="zoom: 67%;" />
  
    - 后续更新(**主节点推送**，**效率，实时性比备库轮询高**)
  
      dump_thread读取主库上的二进制日志中的时间发送给备库io_thread，当该线程追赶上了主库，将进入休眠状态，直到主库发送信号量通知其有新的事务产生时才会被唤醒，继续读取日志推送到备库。
  
  - 复制原理(binlog三种格式)
  
    - 基于语句的复制(statement)
  
      该模式下的binlog记录的是sql语句原文，好处是实现简单，开销小，坏处是sql执行结果可能跟上下文有关，会导致主从不一致。
  
    - 基于行的复制(row)
  
      该模式下的binlog记录的是更新的行数据信息，好处是更高效的复制数据，坏处是空间开销大。
  
    - 混合复制(mixed)
  
      MySql自己判断sql语句是否会引起主备不一致，来选择格式
  
  - M-M结构
  
    双M结构A、B互为主备节点，在状态1时，A节点更新了语句后，生成binlog发给B，B重放语句后也会生成binlog，此时由于是互为主备，因此B节点也将binlog发送给A，出现循环复制现象。为了解决这个问题,
    MySql在binlog中记录了该命令第一次执行时所在实例的sever id，在B重放的过程中，生成与原来的binlog相同的sever id的新binlog，每个库在接收自己主库发过来的日志后，会首先判断日志的sever id，如果与自己一致则直接丢弃。
  
    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\双M.png" style="zoom: 67%;" />
  
    
  
  - 主备延迟
  
    主备数据同步时间点，1.主库 A 执行完成一个事务，写入binlog，我们把这个时刻记为T1；2. 之后传给备库B，我们把备库B接收完这个binlog 的时刻记为T2；3. 备库B执行完成这个事务，我们把这个时刻记为T3。主备的延迟时间 = T3-T1。在MySql中可执行show slave status命令查看主备延迟时间seconds_behind_master，用于表示当前备库延迟了多少秒。由于在网络正常的时候，日志从主库传给备库所需时间很短，即T2-T1很小，因此主备延迟的主要来源是备库接收完binlog后的重放时间。
  
    - 延迟来源(备库消费中转日志速度比主库慢)
  
      - 备库机器性能比主库差
  
        对称部署解决
  
      - 备库压力大
  
        备库上跑了大量查询语句，耗费大量cpu资源，影响同步速度，用一主多从来分摊从库读取压力。
  
      - 大事务
  
        主库等大事务执行完才写binlog，传给备库后，大事务执行时间长，导致从库重放时间长造成从库延迟时间长
  
      - 备库并行复制能力
  
    - 切换策略
  
      - 可靠性优先策略
  
        双M结构下，可靠性优先策略主备切换流程，先判断备库B的延迟时间SBM是否小于预设值，未小于则重试至达到预设值；将A主库改成只读状态，即把readonly设置为true；判断备库B的SBM是否为0，为0则将备库改成可读写状态，即把readonly设置为false；把业务切换到B。该策略小**等待B的SBM至0的时间**是不可写状态，因此该策略切换前需要SBM足够小。
  
        ![](C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\可靠性优先切换.png)
  
      - 可用性优先策略
  
        可用性优先主备切换流程，直接先把连接切到备库B，让B库执行读写，此时就没有不可用时间，但是可能会导致数据不一致。例如，在初始A，B库有3条记录，后续插入两条的情况下，A先执行了一条插入，此时切换到B，B接着执行第二条插入，由于延迟，B还未重放A的relay log，先执行了第二条插入，则第二条数据的自增主键值在B中更小，第一条更大。
  
        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\可用性优先切换.png" style="zoom:50%;" />
  
    - 备库多线程复制机制
  
      由于InnoDB引擎支持行锁因此主库对事务的并发度支持比较好，而备库上单线程sql_thread更新数据导致备库应用日志不够快，造成主备延迟。
  
      <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\主备并行复制.png" style="zoom:50%;" />
  
      为了提高备库复制能力，将原来的sql_thread改成了coordinator线程的功能，负责读取中转日志和分发事务，用worker线程来更新事务，而work线程的个数，由参数slaver_parallel_works决定。 由于不同的事务之间可能会更新同一行，或者同一个事务的多个更新语句必须保证事务特性，因此在进行事务分发的时候需要遵守两个基本要求：1.不能造成更新覆盖，要求更新同一行的两个事务，必须被分发到同一个worker中；2.同一个事务不能被拆开，必须放到同一个worker中。
  
      <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\多线程复制模型.png" style="zoom:50%;" />
  
      - MySQL 5.7.22 并行复制策略
  
        控制参数：binlog-transaction-dependency-tracking
  
        - COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit 来判断事务是否可以并行的策略
        - WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行
        - WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序
  
- 一主多从(读写分离)

  - 主备切换

    大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇 到读性能的问题。而在数据库层解决读性能问题，就是一主多从架构，一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。其中A和A'互为主备，其它的BCD为从库。

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\主备切换 (1主多从).png" style="zoom:50%;" />

    当主库发生故障需要进行主备切换时，A'成为新主库，而BCD也要重新指向A'，因此BCD需要执行change master命令，需要设置需要从A’的的同步位点即对应的文件名和日志偏移量，因此就需要先寻找同步位点。找同步位点有两中方式:

    - 基于位点

      等待A'中转日志同步完，执行show master status命令，得到A'上最新File和Position，取原库A故障的时刻T，用mysqlbinlog工具解析A’的File，得到T时刻的位点，做为BCD的同步位点。由于这个位点会提前，因此会重复发送已经发送的binlog，因此B执行时要主动跳过错误。

    - GTID

      开启GTID模式，每个MySQL实例都维护了一个GTID集合，用来对应"这个实例执行过的所有事务"，因此BCD建立连接后，A'根据自身和BCD的GTID集合的差，自己确定同步位点。 

  - 从库过期读

    由于主从可能存在延迟， 客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态，即过期读。

    - 解决过期读

      - 强制走主库方案

        将查询请求做分类，分为必须最新读和可用旧读两类，分别走主库和从库。

      - sleep 方案

        在发起查询时先执行一条sleep语句，以降低旧读概率。

      - 判断主备无延迟方案

        从库seconds_behind_master=0时才执行查询；

        对比位点确保主备无延迟；

        对比GTID集合确保主备无延迟；

      - 配合semi-sync方案

        事务提交的时候，主库把binlog发给从库；2. 从库收到binlog以后，发回给主库一
        ack，表示收到了；主库收到这个ack以后，才能给客户端返回"事务完成"的确认。

      - 等主库位点方案

      - 等GTID方案
  
- ##### 分库分表

  系统不断运行，存储在数据库的数据量越来越大，系统访问的压力随之增大，数据库的表数据达到千万级别，需要分库分表来减轻系统压力；单表数据的增大，会使得查询变得缓慢，通过分表使得单表数据得到控制，索引大小更小，使得索引和表结构的变更更加方便高效；在每个数据库预留足够实例，便于进行扩容操作时减少对应用层配置的更改。

  - 数据拆分方式

    - 垂直拆分

      根据业务的维度，将原本一个库中的表拆分成多个表，每个库中的表与原表结构不同。

    - 水平拆分

      根据分片算法，将一个库拆分成多个库，每个库中表依旧保留原表结构。

      - 例子

        有一张10亿数据记录的表，按经验mysql数据库一张表的数据记录极限一般在5000万，所以需要进行分片存储(水平拆分)，切片数量为20，即20个数据库表。如果将20个相同业务表存放在同一个数据库中，那么单个数据库实例的网卡I/O、内存、CPU和磁盘性能是有限的，随着数据库访问频率的增加，会导致单个数据库实例和数据库达到性能瓶颈，因此我们需要将20个表分到多个数据库和多个数据库实例中。TODO 对数据库实例和数据库表的数量的评估如下：

        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\水平拆分.png" style="zoom: 67%;" />

        - 分库分表方案

          - 客户端分片

            在每个应用服务器节点上设置分片规则，实现分片逻辑。分为应用层直接实现、定制JDBC协议实现、定制ORM框架实现三种。

            <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\客户端分片.png" style="zoom: 50%;" />

          - 代理分片

            代理分片就是在应用层和数据库层之间添加一个代理层，把分片的路由规则配置在代理层，代理层对外提供与JDBC兼容的接口给应用层，在业务实现之后，在代理层配置路由规则即可，Mycat就是基于该解决方案。

            <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\代理分片.png" style="zoom:50%;" />

          - 支持事务的分布式数据库

            支持分布式事务的框架，目前有OceanBase、TiDB框架，这些框架将可伸缩特定和分布式事务的实现包装到了分布式数据库内部实现，对使用者透明，使用者不需要直接控制这些特性，但是对事务的支持不如关系型数据，适合大数据日志系统、统计系统、查询系统、社交网站等。

        - 水平拆分分片策略

          - 哈希切片

            对某个字段进行哈希，在对分片总数求模。

          - 时间切片

            对记录按时间范围进行切片。

      - 垂直和水平拆分优缺点

        - 垂直拆分
          - 拆分后业务清晰，拆分规则明确
          - 系统间易整合、扩展
          - 部分业务无法进行关联、只能通过接口方式，增加系统复杂性
          - 受业务种类限制
        - 水平拆分
          - 单库单表数据量级小，性能高
          - 表结构相同，应用层改造少，只需增加路由规则
          - 提高系统稳定性和负载能力
          - 切分后数据分散，很难利用数据库关联，跨库查询性能差
          - 拆分规则难以抽象，分片数据一致性问题

      - 引入的问题

        - 扩容与迁移

        - 分库分表关联、范围、排序查询

          多次单表查询汇总

        - 跨库事务

          使用分布式事务

        - 主流解决方案

          - ShardingJDBC
          - Mycat

        

      

  

  

  

  