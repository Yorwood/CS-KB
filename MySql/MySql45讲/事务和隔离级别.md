##### 事务

- 定义

  事务就是要保证一组数据库操作，要么全部成功，要么全部失败。事务支持是在存储引擎层实现的，因此不是所有存储引擎都支持事务，例如MyISAM就不支持事务。

- ACID

  - 原子性：同定义
  - 一致性：数据库总是从一个一致性状态转换到另外一个一致性状态(即数据库行为符合规范和约束，例如事务执行时崩溃，可以回滚到前一个状态，不会处于中间的未定义的状态)。
  - 隔离性：一个事务所作的修改在提交以前一般对其他事务不可见(取决于隔离级别)。
  - 持久性：事务提交后，其所作的修改会被永久保存到数据库，即落到磁盘(持久性也取决与持久化策略)。
  
- ACID实现

  - undo log - 原子性
  - redo log - 持久性
  - MVCC和锁 - 隔离性

##### 隔离性

- 隔离级别

  - 读未提交：一个事务还没提交时，它做的变更其它事务就能看到。

  - 读已提交(RC)：一个事务提交之后，它做的变更其它事务才能看到。

  - 可重复读(RR)：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。

  - 串行化：对同一行记录，写加写锁，读加读锁，当发生读写锁冲突时，后访问的事务会阻塞到前一个事务执行完成。

  - 例子：对于下面A、B两个事务，查询同一个表中同一个单列属性的值为1的记录；

    RU：V1=2，V2=2，V3=2；(V1直接读到B更新的脏数据)

    RC：V1=1，V2=2，V3=2；(V2可以读到B提交后的数据，执行SQL语句时创建视图)

    RR：V1=1，V2=1，V3=2；(V1、V2均只能查询到原始数据，事务启动时创建视图)

    Serial：V1=1，V2=1，V3=2；(B事务修改记录时，会被阻塞，直到A提交)

<img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\隔离级别-example.png" style="zoom:50%;" />

- 事务隔离的实现

  - MVCC

    InnoDB实现了MVCC(多版本控制机制)，InnoDB里面每个事务有个唯一的事务ID，叫作transaction id，它是在事务开始时向InnoDB的事务系统申请的，是按申请顺序严格递增的。每行数据有多个版本，
    每次事务更新数据的时候，都会生成一个新的数据版本，并且将该事务的transaction id赋值给该版
    本数据的事务ID，记为row trx_id，同时旧的数据版本也会保留，新旧版本间通过undo log信息进行转换。下面图中虚线部分就是undo log，前面三个版本并不是物理存在的，而是可以通过当前版本和undo log根据需要计算出来的。

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\MVCC.png" style="zoom:50%;" />

  - RR

    可重复读，一个**事务启动**的时候，能够看到所有已经提交的事务结果，但是之后这个事务执行期间，其它事务的更新对它不可见(除事务自己外的一切更新都不可见)。

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\事务高低水位.png" style="zoom:67%;" />

    InnoDB利用MVCC来实现RR的快照读，InnoDB为每个事务构造一个数组，数组记录事务在启动瞬间，当前正在活跃的所有事务的ID(记录了所有还未提交的事务)，数组里面事务ID的最小值记为低水位，当前系统已经创建过的事务的ID的最大值~~+1~~记为高水位，这个**视图数组**和**高水位**构成了当前事务的一致性视图
    (read-view)。数据版本的可见性，就可以根据这个一致性视图来判断，数据记录的**版本小于低水位**即绿色部分，那么肯定是已经在当前事务启动前提交的，因此**可见**；数据记录的版本**大于高水位**则表示是当前事务启动之后的事务更新的，则**不可见**；数据记录的版本落在**高低水位之间**，则要判断该事务是否是数组中记录的**活跃事务**，若是则表明当前事务启动时未提交，**不可见**，否则表示是**已经提交的事务**，**可见**(注意，事务ID属于数组范围内的事务，不一定是活跃事务，也就是可能已经提交过了，则不在数组记录中，因为事务的ID是递增的，但是提交是无序的)。

    下图实例:

    1. 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99
    2. 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务； 
    3. 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90

    对A来说，启动瞬间活跃事务只有事务99，当前系统版本已经创建的事务的最大ID为100，则高水位为100，低水位为99，一致性视图为[99,100]

    对B来说，活跃事务为99，100，低水位为99，高水位为101，[99，100，101]

    对C来说，活跃事务为99,100,101,低水位为99，高水位为102，[99，100，101，102]

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\rr-example.png" style="zoom:50%;" />

    A的查询过程，首先查询到当前版本数据(1,3)，大于高水位，undo，找到(1,2)，继续undo，找到(1，1)低水位符合，返回。

    B为啥会更新为(1,3)，怎么读到了(1,2)？

    因为**更新操作**是基于**当前读**规则的，当前读是读取已经**提交**的**最新版本**。

    那么，如果C更新后，在B更新之后提交呢？

    C**更新记录**前需要拿到**行写锁**，**提交后才释放**，所以B当前读时记录被C持有行写锁，会阻塞至C提交释放行写锁，因此B依然可读到当前最新版本。

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\更新-当前读.png" style="zoom:50%;" />

  - RC

    在读提交隔离级别下，**每一个语句执行前**都会重新算出一个新的视图。

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\rc-read-view.png" style="zoom:50%;" />

    事务A在执行查询语句前，版本101，102，都在该语句之前，但是由于102未提交，不可见，101可见。

    - 小结

      对于可重复读，查询只承认在**事务启动前**就**已经提交**完成的数据

      对于读提交，查询只承认在**语句启动前**就**已经提交**完成的数据

  - 幻读

    在RR级别下，一个事务在前后两次查询同一个访问的时候，后一次查询看到了前一次查询没有看到的行(幻读只在当前读查询情况下发生，且指的是看到了新插入的行的情况)。

    - 幻读解决？行锁

      行锁无法解决幻读，如下图，假设对d=5进行当前读，对扫描中的所有行加了行锁，那么B的修改语句会被阻塞，但是C的插入语句不会，因为之前还未存在该行，故无法加锁。

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\幻读-行锁.png" style="zoom:50%;" />

    - 间隙锁和next-lock key

      从上面的情况可知，行锁无法解决幻读的原因是插入操作更新的是记录之间的间隙，因此InnoDB引入了间隙锁(gap lock)，例如下面的6条记录会产生7个间隙，**间隙锁就是对记录之间的间隙进行加锁**，间隙锁保护的是防止间隙之间插入新记录这个操作。间隙锁和行锁一起合称next-lock key，为**前开后闭区间**，解决幻读问题。

      <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\间隙锁-next lock key.png" style="zoom: 50%;" />

    - next-lock key加锁规则(RR级别下间隙锁有效)

      - 加锁单位-next-lock key，**前开后闭区间**

      - 查询过程中访问到对象才加锁(如：**锁是加到索引**上，查询过程用的是覆盖索引，则只会对覆盖索引加锁，不会影响聚簇索引的更新)

      - 等值查询时，唯一索引加锁时，该值存在时，退化为行锁(唯一索引该值存在，则只能对该值进行修改，不可能插入相同值记录，因此行锁即可)

      - 等值查询时，索引查询时右边最后一个(非唯一索引需遍历到第一个大于条件)，该值不存在时，

        退化为间隙锁(由于最后一个记录该值大于查询值，因此只需锁住间隙防止插入更新)

      - bug：唯一索引上的范围查询会访问到第一个不满足条件的值为止

      - next-lock key实质上是两段加锁，先加间隙锁再加行锁，因此可能会有两个事务同时加了间隙锁(间隙锁只对插入操作冲突)，导致的死锁问题

      

      

      

      

    

    

