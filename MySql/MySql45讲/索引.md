##### 索引

- **索引类型**

  - B+-Tree

    - 特点

      B+-Tree非叶子节点不存储数据，叶子节点不存储指针，叶子节点之间有指针相连。树高较低，访问数据IO开销少，便于顺序访问和区间查询；树高三层的B+-Tree，如对大整形主键8B和指针6B进行索引，假设叶子节点记录平均开销为1k，则页16KB，16KB/14B=1170，三层索引1170 * 1170 * 16 =20000000千万级别。

      

    <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\B+Tree.png" style="zoom:50%;" />

    - 对比

      B+-Tree相比其它的如BST、红黑树等由于是多叉树树高更低，访问IO开销小；对比B-Tree只在叶子节点存储数据，便于区间查询，而B-Tree非叶子节点也存储数据，需要进行中序遍历。

    - Innodb和MyISAM

      - 聚簇索引

        Innodb使用B+-Tree作为索引底层结构，其数据存储就是以主键为顺序组织的B+-Tree，是聚簇索引，叶子节点直接存储数据，索引和数据存放在一起。

      - 非聚簇索引

        MyISAM也使用B+-Tree作为索引底层结构，但是B+-Tree只作为索引，叶子节点存储的是数据的地址指针，数据和索引分开存储。

        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\非聚簇索引.png" style="zoom: 50%;" />

    - 更新

      B+-Tree插入和更新时遇到页满或者页负载小于填充因子时，需要进行页分裂或者合并操作；B+-Tree结构页分裂时从中间值开始对半分裂，在数据库插入时很多情况主键值是有序的，从中间分裂会造成很多页浪费，MySql对分裂操作进行了**优化**，可以决定**分裂方向**，特别的自增插入时分裂点为插入记录本身。

    - 二级索引(非聚簇索引)

      二级索引叶子节点存的是主键的值，基于二级索引的查询，由于没有记录的全部信息，往往需要拿到记录的主键值之后再去主键索引上查一次，称为回表。

      <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\二级索引.png" style="zoom:50%;" />

      - 唯一索引

        唯一索引就是索引键值不相同的索引，例如主键索引，**唯一索引相比普通索引的缺点**是在插入记录的时候，由于唯一性在内存未命中时需要读取相应节点页进行唯一性判断，无法利用**change buffer**来提高插入效率。

    - 覆盖索引

      索引的叶子节点中已经包含要查询的数据，如上图要查询k=3记录的主键，此时主键已经在该二级索引的叶子节点中，可以直接返回，不用回表。

    - 联合索引

      对表上的多个列进行索引，索引项按照索引定义时出现的字段顺序排列。联合索引中字段的排列顺序的选择，需要结合业务情况，选择复用索引最多的顺序，即多数查询可以利用该索引的顺序，其次还可以考虑复用索引后，需要额外建立单独字段索引时字段较小空间开销更小的顺序。

      - 最左前缀原则

        查询条件满足最左前缀原则即可用联合索引进行加速查询，即查询条件是联合索引的最左N个字段或者字符串索引的最左M个字符。

        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\联合索引.png" style="zoom:50%;" />

      - 索引下推

        如果查询条件只用了部分最左前缀，后面不符合最左前缀，后面的字段判断会在二级索引进行查询的时候，如果字段可以获取，则直接在二级索引上进行判断过滤，减少回表查询次数。

        ```mysql
        mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;
        ```

        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\索引下推.png" style="zoom:50%;" />

      - 字符串加索引(前缀索引)

        如果我们需要给长字符串字段加索引时，由于长度较长会造成空间开销较大，根据最左前缀原则，我们可以截取合适的前缀长度来作为索引字段，这样能够节省空间开销。

        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\字符串索引-1.png" style="zoom:50%;" />

        

        <img src="C:\Users\18160\Desktop\YW\JAVA\KB\CS-KB\MySql\MySql45讲\fig\字符串索引-2.png" style="zoom: 67%;" />

        - 选择度(区分度)

          选择截取长度时，需要考虑截取字段的区分度，也即截取字段的不同重复索引值和记录总基数的比值，比值越接近1区分度越高，截取长度选择是要权衡选择度和空间开销。

        - 前缀索引缺点

          前缀索引由于截取了字段，所以无法被用于排序ORDER BY和分组GROUP BY，以及无法用于覆盖扫描，其次会增加查询扫描次数。	

      - 匹配规则

        - 匹配谓词和筛选谓词
      
          匹配谓词即可以用来进行索引的判断条件，筛选谓词则是不符合最左前缀的条件，只能用来筛选而不能走索引比较。
      
        - 例子
      
          ```mysql
          表T1上有列C1、C2、C3、C4、C5、C6、C7、C8。其中在C1,C2,C3,C4上有索引key(1,2,3,4)
          
          Select * From T1 Where C2=4 And C3=7 And C4=2 (无匹配谓词)
          Select * From T1 Where C1<>5 And C2=4 And C3=7 (无匹配谓词)
          Select * From T1 Where C2=4 And C3=7 And C1=5 (全匹配谓词，优化器等值重排)
          Select * From T1 Where C1=5 And C2=4 And C4=2 And C6=10 (C1、C2匹配谓词)
          Select * From T1 Where  C1=5 And C2=4 And C3>7 And C4=2(C1、C2、C7匹配谓词)
          ```

  - 哈希索引

     基于哈希表实现，存储引擎对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同的键值的行计算出来的哈希码不同。哈希索引讲索引的哈希码存储仔索引中，同时仔哈希表中保存指向每个数据行的指针。Innodb支持哈希索引，但是是自适应的，会自己讲频繁访问的索引值在内存中基于B-Tree索引之上再建立哈希索引，是一个完全自动的、内部的行为，用户无法控制。

    - Memory

      MySql中Memory引擎显示支持哈希索引，并且支持非唯一哈希索引，用拉链法接近冲突。

  - R-Tree

    空间索引从所有维度来索引数据，查询时可以使用任意维度组合进行查询。MyISAM引擎支持空间索引。

  - 全文索引

    全文索引是一种特殊索引，查找的是文本中的关键词，倒排索引，类似搜索引擎功能。

- ##### 索引失效

  - 不等式<> 或 !=

    ```mysql
    SELECT * FROM `t_index` WHERE key1 <> '1';
    ```

  - 传入值与字段类型不一致

    ```mysql
    SELECT * FROM `t_index` WHERE key1 = 1;
    ```

  - 查询字段使用函数计算

    ```mysql
    SELECT * FROM `t_index` WHERE key1 + 1 = 1;
    SELECT * FROM `t_index` WHERE CCHAR_LENGTH(key1) = 1;
    ```

  - 模糊前缀查询

    ```mysql
    SELECT * FROM `t_index` WHERE key1 LIKE  '%3';
    ```

  - or连接

    ```mysql
    SELECT * FROM `t_index` WHERE key1 = 1 or key2 = 2;
    ```

  -  in，not in

    优化器判断查询基数较大时，回表开销大，直接走全表扫描

- 索引字段选择

  - 经常Where子句中的大表字段
  - 选择性高的字段
  - 频繁查询的字段
  - 非NULL字段
  - 查询中与其他表关联的字段，外键关系建立索引
  - 查询中排序的字段
  - 整形和String
    - 整形开销小，且可以使用自增。
    - 字符串开销大，通常比整形慢
    - 随机字符串，导致插入和查询慢，因为随机插入会造成页分裂和页碎片，并且逻辑相邻的行会分布在磁盘和内存的不同地方，访问局部性原理失效			

