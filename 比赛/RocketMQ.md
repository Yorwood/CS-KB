##### RocketMQ

- 赛题

  - 题目

     实现简单的消息读取与存储，即实现append和getRange方法；append参数为消息data(ByteBuffer)、topic(String)、queueId(int)，返回值为消息存盘时在该主题和队列下的偏移offset；getRange参数为topic、queueId、offset，要求返回从该对应消息起的连续n条消息；

  - 要求

    消息存取时一致，且具有断电持久性；

  - 评测

    10~50个线程，每个线程发送若干个随机topic(0<=topic<=99)，每个topic有N个queueId
    (0<=N<=99）；第一阶段持续写入75GiB数据；第二阶段写入50GiB数据，且同时随机读取消息
    直到没有数据停止；

- 分析

  - 断电丢失

    由于需要保证断电一致性，则追加消息函数返回前，必须要将消息落盘；

    - FileChannel(文件写入)

      根据经验我们使用了FileChannel来进行文件的读写(当然有些场景下MMap性能更好)，OS为了提高文件读写效率，会设置一个文件系统缓存，FileChannel文件写入会先将数据写入到file中，再刷到磁盘中，因此我们需要在写入数据时，手动调用force方法(系统调用fsync)进行强制刷盘，但这样就会产生一个写放大问题；

      - 写放大问题

         由于线程携带的消息大小是100B-17KiB的随机值，一次写入的数据块大小非常小，而且我们强制进行刷盘，无法利用文件系统缓存，导致IOPS很大，这样写磁盘的性能(吞吐量)会非常差；

      - 随机写问题

        由于每个线程会发送若干个主题的随机队列的消息，因此如果我们直接按topic来分文件，则一个线程需要随机将数据写入多个文件，这里随机写文件对磁盘是不友好的；

      - 解决方案

        - 按topic分组和消息缓存

          为了减少随机读写问题，我们将topic进行分为N组，每组对应一个文件，并且我们给每个文件都开了一个内存缓存数组，利用cas(原子自增变量)来获取缓存数组空间(足够大)，放置线程的对应消息，我们设计了一个粗糙的刷盘策略，每个线程将消息填完自己的缓存后，sleep一段时间，醒来后进行抢锁，进行缓存刷盘，写完后唤醒其它等待线程，返回；这里我们根据实际测试效果，发现分组数N=4时性能最好；**[我们这样设计的原因是因为测评说线程数量是随机，实质上线程数量在一次测评过程中不会变，因此有很多选手直接等待一段时间后统计线程总数数，这样就不用条件等待机制了，直接统计阻塞线程数，好亏，CPU调度废了很多时间]**

        - 4K对齐

          OS读写基本单位为4KB，我们缓存的消息大小是不定的，如果我们直接写入，则可能跨页，如5kb，一个页只写入1kb，下次写入时会先将该数据1kb读取出来和新数据合并后写入新页；因此我们将缓存数据补齐到4kb整数倍写入；	

    <img src="C:\Users\18160\AppData\Roaming\Typora\typora-user-images\image-20211229210805556.png" alt="image-20211229210805556" style="zoom: 67%;" />

<img src="C:\Users\18160\AppData\Roaming\Typora\typora-user-images\image-20211229203228632.png" alt="image-20211229203228632" style="zoom:50%;" />

- 随机读

  - 内存索引缓存

    每次写消息时，将消息写一份到磁盘，写一份到PMEM中，在内存中用**HashMap**来存储消息在PMEM或者磁盘中对应的文件和偏移量，查询时，先判断消息是否命中PMEM，是则直接根据偏移量查PMEM，否则根据偏移量查磁盘文件；如果断电了，则HashMap肯定为空，此时可以根据消息计算对应文件，去扫描磁盘文件进行查询；

  - 消息格式化存储

    加快扫描查询；

    ![image-20211229222201360](C:\Users\18160\AppData\Roaming\Typora\typora-user-images\image-20211229222201360.png)			

- 不足

  - cpu缓存

    数组存索引比HashMap开销小，key做索引，相同队列查询时，命中率高；

  - 文件预分配

    追加写入扩展，和直接开辟空的大文件

  - PMEM缓存池复用

  - 没有充分利用DRAM做消息缓存