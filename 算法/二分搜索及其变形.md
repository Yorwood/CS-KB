**二分搜索及其变形**

二分搜索的核心思想就是通过数组的有序性，每次选择中间的元素的值来对目标值(可能)所在的区间进行判断，从而不断的减小搜索空间。因此，二分搜索的写法根据目标值语义不同(equal、first<=、last>=)和对区间划分策略有关。

这里为了方便，我们采取的区间划分的策略为通过中间值，将区间划分为(潜在)有效区间和无效区间两部分。

```java
//有效区间、无效区间的划分：主要是有效值等号的归属区间是左侧还是右侧
//核心策略：1.判断条件为lo<hi，以保证跳槽循环lo==hi,减少判断麻烦
//		  2.根据目标值语义：
//		   a:找第一个相等或者不小于
//			  我们应该找到第一个有效值，也就是我们要把其所有左侧无效区间给删除，选择将有效值右保留
//		   b:找最后一个相等或者不大于
//			  我们应该找到最后一个有效值，也就是我们要把其所有右侧无效区间给删除，选择将有效值左保留

//order 1 2 3 4 (升序)

//first equal
int binarySearh(int order[],int target){
    int lo = 0, hi = order.length-1;
    while(lo < hi){ //这里我们统一用lo < hi作为循环条件，这样可以保证最后输出是lo=hi
        int mid = lo + (hi-lo)/2;
        if(order[mid] < target) lo = mid +1;//去除左侧无效区间
        else right = mid;//保留右侧潜在区间
    }
    
    if(order[lo] == target) return lo; //由于有效区间是右保留，故判断第一个值即可
    return -1;
}

//first >= 
int binarySearh(int order[],int target){
    int lo = 0, hi = order.length-1;
    while(lo < hi){ //这里我们统一用lo < hi作为循环条件，这样可以保证最后输出是lo=hi
        int mid = lo + (hi-lo)/2;
        if(order[mid] < target) lo = mid +1;//去除左侧无效区间
        else right = mid;//保留右侧潜在区间
    }
    
    if(order[lo] >= target) return lo; //由于有效区间是右保留，故判断第一个值即可
    return -1;
}

//last equal
int binarySearh(int order[],int target){
    int lo = 0, hi = order.length-1;
    while(lo < hi){ //这里我们统一用lo < hi作为循环条件，这样可以保证最后输出是lo=hi
        int mid = lo + (hi-lo+1)/2; //由于是左保留，需要mid向上取整，否则hi=lo+1时，死循环
        if(order[mid] > target) hi = mid -1;//去除右侧无效区间
        else lo = mid;//保留左侧潜在区间
    }
    
    if(order[lo] == target) return lo; //由于有效区间是左保留，故判断第一个值即可
    return -1;
}


//last <=
int binarySearh(int order[],int target){
    int lo = 0, hi = order.length-1;
    while(lo < hi){ //这里我们统一用lo < hi作为循环条件，这样可以保证最后输出是lo=hi
        int mid = lo + (hi-lo+1)/2;//由于是左保留，需要mid向上取整，否则hi=lo+1时，死循环
        if(order[mid] > target) hi = mid -1;//去除右侧无效区间
        else lo = mid;//保留左侧潜在区间
    }
    
    if(order[lo] <= target) return lo; //由于有效区间是左保留，故判断第一个值即可
    return -1;
}




```

