#### 1.[剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

`[3,3,1,3] 1`

`[3,4,5,1,2] 1`

```java
public int minArray(int[] numbers) {
        int l =0, h = numbers.length-1;
        while(l < h){
            int mid = (l+h)/2;
            if(numbers[mid] > numbers[h]){ // numbers[h]比numbers[numbers.lenght-1]高效
                l = mid + 1;
            }
            else if(numbers[mid] < numbers[h]){
                h = mid;
            }
            else{ //有重复元素，故相等情况需单独遍历
                int min = numbers[l];
                for(int i = l; i <= h; i++){
                    if(min > numbers[i])min = numbers[i];
                }
                return min;
            }
        }
        return numbers[l];
    }
```

#### 2.[剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

二维字符网格，找目标字符串

```java
	int walk[][] = {{-1,0},{1,0},{0,-1},{0,1}};//注意声明形式是walk[][], dfs,遍历方向
    
    public boolean exist(char[][] board, String word) {
        char[] wordArr = word.toCharArray();//转换为字符数组更简洁高效
        int m = board.length, n = board[0].length;
        boolean flag = false;
        for(int i =0; i < m; i++){
            for(int j=0; j < n; j++){
                if(find(board,wordArr,i,j,0)) return true;//需要挨个作为起始点
            }
        }
        return false;
    }
    
   //以当前传入坐标为待判定字符，形式简单
    public boolean find(char[][] board, char[] wordArr, int r,int c,int len){
        
        if(wordArr.length == len){ //len只记录正确个数，省去stringbuilder进行缓存
            return true;
        }

        boolean flag = false;//作为局部标记非全局标记逻辑更简洁
        if(r >= 0 && r < board.length && c >= 0 &&
            c  < board[0].length  && board[r][c] == wordArr[len]){
            char tmp = board[r][c];
            board[r][c] = ' ';   
            for(int i = 0 ; i < 4; i++){
                flag = flag || find(board,wordArr,r+walk[i][0],c+walk[i][1] ,len+1);
            }
            board[r][c] = tmp;
        }
        
        return flag;
    }
```

