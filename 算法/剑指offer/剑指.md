#### 1.[剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

```
[3,3,1,3] 1
[3,4,5,1,2] 1
```

```java
public int minArray(int[] numbers) {
        int l =0, h = numbers.length-1;
        while(l < h){
            int mid = (l+h)/2;
            if(numbers[mid] > numbers[h]){ // numbers[h]比numbers[numbers.lenght-1]高效
                l = mid + 1;
            }
            else if(numbers[mid] < numbers[h]){
                h = mid;
            }
            else{ //有重复元素，故相等情况需单独遍历
                int min = numbers[l];
                for(int i = l; i <= h; i++){
                    if(min > numbers[i])min = numbers[i];
                }
                return min;
            }
        }
        return numbers[l];
    }
```

#### 2.[剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```
二维字符网格，找目标字符串
```

```java
	int walk[][] = {{-1,0},{1,0},{0,-1},{0,1}};//注意声明形式是walk[][], dfs,遍历方向
    
    public boolean exist(char[][] board, String word) {
        char[] wordArr = word.toCharArray();//转换为字符数组更简洁高效
        int m = board.length, n = board[0].length;
        boolean flag = false;
        for(int i =0; i < m; i++){
            for(int j=0; j < n; j++){
                if(find(board,wordArr,i,j,0)) return true;//需要挨个作为起始点
            }
        }
        return false;
    }
    
   //以当前传入坐标为待判定字符，形式简单
    public boolean find(char[][] board, char[] wordArr, int r,int c,int len){
        
        if(wordArr.length == len){ //len只记录正确个数，省去stringbuilder进行缓存
            return true;
        }

        boolean flag = false;//作为局部标记非全局标记逻辑更简洁
        if(r >= 0 && r < board.length && c >= 0 &&
            c  < board[0].length  && board[r][c] == wordArr[len]){
            char tmp = board[r][c];
            board[r][c] = ' ';   
            for(int i = 0 ; i < 4; i++){
                flag = flag || find(board,wordArr,r+walk[i][0],c+walk[i][1] ,len+1);
            }
            board[r][c] = tmp;
        }
        
        return flag;
    }
```

#### 3.[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```
s = "We are happy."
"We%20are%20happy."
```

```
Tips:扩张替换问题，从后往前逆序，避免覆盖
```

```java
public String replaceSpace(String s) {
        int cnt  = 0;
        char[] cStr =  s.toCharArray();
        int len = cStr.length;
        for(int i = 0; i < len; i++ ){
            if(cStr[i] == ' ')
            {
                cnt++;
            }
        }
        if(cnt == 0) return s;
        char[] res = new char[len+2*cnt];
        int j = len+2*cnt -1;
        for(int i =len-1; i >= 0; i--){
            if(cStr[i] == ' '){
                res[j--] = '0';
                res[j--] = '2';
                res[j--] = '%';
            }
            else{
                res[j--] = cStr[i];
            }
        }
        return new String(res);
    }
```

#### 4.[剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```
输入：m = 2, n = 3, k = 1
输出：3
```

```java
int[][] walk = {{-1,0}, {1,0}, {0,-1}, {0,1}}; //可以直接声明并初始化匿名对象int[],不能给定长度
    Queue<int[]> q = new LinkedList();//声明需要指定模板类型
    int cnt = 0;
    
    public int movingCount(int m, int n, int k) {
        int vis[][] = new int[m][n];
        q.offer(new int[]{0,0});//可以直接声明并初始化匿名对象int[],不能给定长度[2]
        vis[0][0] = 1;
        while(!q.isEmpty()){
            int[] tmp = q.poll();
            cnt++;
            for(int i = 0; i < 4; i++ ){
                int r = tmp[0]+walk[i][0];
                int c = tmp[1]+walk[i][1];
                if(r >= 0 && r < m && c >= 0 && c < n && vis[r][c] == 0 && 
                  numOfDigit(r) +numOfDigit(c) <= k) {
                    q.offer(new int[]{r,c});
                    vis[r][c] = 1;
                }
            }
        }
        return cnt;

    }

    public int numOfDigit(int d){
        int tot = 0;
        while(d > 0){
            tot += d%10;
            d /= 10;
        }
        return tot;
    } 
```

#### 5.[剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```
输入：head = [1,3,2]
输出：[2,3,1]
```

```
Tips:可以利用栈来逆序打印，在栈底时开辟数组；
也可以反转链表后，开辟数组，再输出，链表操作一般声明一个辅助的哑节点dumb，便于理清逻辑；
```

```java
	class Solution {
    ArrayList<Integer> res = new ArrayList();
    public int[] reversePrint(ListNode head) {
        rec(head);
        int[] resInt = new int[res.size()];
        for(int i=0; i < res.size(); i++){
            resInt[i] = res.get(i);
        }
        return resInt;
        
    }
    public void rec(ListNode head){
        if(head == null) return;
        rec(head.next);
        res.add(head.val); 
    }
}
```

#### 6.[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)（无重复值）

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

```
Tips:
前序：根左右
中序：左右根
前序定根->在中序中定左右子树个数->定前序中左右子树分界点
```

```java
HashMap<Integer,Integer> idxs = new HashMap();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        //避免每次在中序序列中遍历寻根
        for(int i = 0; i < inorder.length; i++){
            idxs.put(inorder[i],i);
        }
        return recBuild(preorder,inorder,0,preorder.length-1,0,inorder.length-1);
    }

  public TreeNode recBuild(int[] preorder, int[] inorder,int p_l, int p_r, int i_l, int 	i_r){
        if(p_l > p_r) return null;
        TreeNode root = new TreeNode(preorder[p_l]);//前序序列首节点是根节点
        int idx = idxs.get(preorder[p_l]);//中序序列中根节点位置
        int left_len = idx - i_l;//中序序列划分左、右子树
        int right_len = i_r - idx;
        //根据左右子树个数，找到左右子树在前序序列中的分界点p_l+left_len
        root.left = recBuild(preorder,inorder,p_l+1,p_l+left_len,i_l,idx-1);
        root.right = recBuild(preorder,inorder,p_r-right_len+1,p_r,idx+1,i_r);
        return root;
    }

```

#### 7.[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```
Tips:链表操作一般声明一个辅助的哑节点dumb，便于理清逻辑；当前节点cur初始指向dumb
```

```java
 public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dumb = new ListNode(-1);
        ListNode cur = dumb;
        if(l1 == null && l2 == null) return null;
        if(l1 == null) return l2;
        if(l2 == null) return l1;
    
        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }
            else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = l1 == null ? l2 : l1;
        return dumb.next;
    }
```

#### 8.[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```
B树是A树的子结构，空树不是任何树的子结构(子结构不是子树，不一定要匹配到叶节点)
```

```
Tips:二叉树问题一般用递归，子结构必须一一对应(&&)，直到目标树比到null，但是目标树可以是原树的任意子树的子结构(||)
```

```java
public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(B == null) return false;
        if(A == null) return false;
        return rec(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);
    }

    public boolean rec(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return rec(A.left,B.left) && rec(A.right,B.right);
    }
```

#### 9.[剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

```java
public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        mirrorTree(root.right);
        mirrorTree(root.left);
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        return root;
    }
```

#### 10.[剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
//判断二叉树是否镜像对称
```

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return rec(root.left,root.right);
    }

    public boolean rec(TreeNode A, TreeNode B){
        if(A == B) return true;
        if(A == null || B == null || A.val != B.val) return false;
        return rec(A.left,B.right) && rec(A.right,B.left);
    }
}
```

#### 11.[剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

```
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）
```

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int num = 0;
        while(n != 0){
            if( (n&1) == 1) num++;
            n >>>= 1; //注意使用无符号右移，即右移后首位补0
        }
        return num;
    }
}
```

#### 12.[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

```
实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题
```

```java
class Solution {
    public double myPow(double x, int n) {
        int flag = 0;
        long n_l = n; //注意负整数转换相反数时越界，先转成long类型存储
        if(n_l < 0) {
            n_l = -n_l;
            flag = 1;
        }
        double base = x;
        double res = 1;
        while(n_l != 0){
            if( (n_l&1) == 1){//二进制位为1时累乘
                res *= base;
            }
            base *= base;//2次幂
            n_l >>= 1;
        }
        if(flag == 1){
            res = 1/res;
        }
        return res;
    }
}
```

#### 13.[剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点
```

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null && cur.val != val){
            pre = cur;
            cur = cur.next;
        }
        if(pre == null) return head.next;
        pre.next = cur.next;
        return head;
    }
}
```

#### 14.[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

```
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分
```

```java
class Solution {
    public int[] exchange(int[] nums) {
        int i = 0;
        int j = nums.length -1;
        int tmp;
        while(i < j){ //走一遍快排过程，交换奇偶
            while(i < j && nums[i] % 2 == 1){
                i++;
            }
            while(i < j && nums[j] % 2 == 0){
                j--;
            }
            if(i < j){
              tmp = nums[i];
              nums[i] = nums[j];
              nums[j] = tmp;   
            }
        }
        return nums;
    }
}
```

#### 15.[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，从1开始计数，即链表的尾节点是倒数第1个节点
```

```
Tips:快慢指针
```

```java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode slow = head;
        ListNode fast = head;
        k--;
        while(k-- > 0){
            fast = fast.next;
        }
        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

#### 16.[剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

```
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点
```

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dumb = new ListNode(-1);//先定义一个哑节点
        ListNode next = head;
        while(head != null){
            next = head.next;
            head.next = dumb.next;//用当前节点指向哑节点的next(即当前链表头)
            dumb.next = head;
            head = next;
        }
        return dumb.next;
    }
}
```

#### 17.[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

```
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等
```

```
Tips: 方法1：可以用一个辅助栈来模拟入栈顺序,在入栈过程中如果栈顶值等于当前出栈值，则一直出栈，最后判断栈中元素是否都已出栈，否则则为不合法出栈序列; 方法2：根据后进先出，位次在大的先弹出，检验出栈序列，当前出栈序列的位次为x，则大于x且在当前已经出栈的最大位次之间(因为可以先弹出后再压栈，所以为已出栈中的最大值)的元素必然已经出栈;
```

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if(pushed.length == 0)return true;
        Stack<Integer> s =  new Stack();
        int j = 0;
        for(int i=0; i < pushed.length; i++){
            s.push(pushed[i]);
            while(s.size()>0 && s.peek() == popped[j]){
                s.pop();
                j++;
            }
        }
        if(s.size() == 0)
            return true;
        return false;
    }
}
```

```java
class Solution {
    HashMap<Integer,Integer> indexNum = new HashMap();
    int[] pop ;
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        pop =  new int[pushed.length];
        for(int i = 0 ; i < pushed.length  ; i++){
            indexNum.put(pushed[i],i);
        }
        int tmp , index, max = -1;
        for(int i = 0 ; i < popped.length ; i++){
            tmp = popped[i];
            index = indexNum.get(tmp);
            if(max > index){
                for(int j = index +1; j <= max ; j++ ){
                    if(pop[j] == 0) return false;
                }
            }
            pop[index] = 1;
            if(index > max) max = index;
        }
        return true;
    }
}
```

#### 18.[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

```
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同
```

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return rec(postorder,0,postorder.length-1);
    }
    
    public boolean rec(int[] postorder, int s, int e) {
        if(e-s <= 1) return true; //0~2长度的数组均合法
        int root = postorder[e];
        int p = s;
        int last_left = s;
        while(p < e && postorder[p] < root) {p++;} //最后一个左子树节点位置
        last_left = p-1;
        while(p < e && postorder[p] > root){p++;} //检查右子树是否合法
        if(p < e) return false;
        return rec(postorder,s,last_left) && rec(postorder,last_left+1,e-1);
    }
}
```

#### 19.[剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        rec(root,target,new ArrayList<Integer>());
        return res;
    }

    public void rec(TreeNode root, int target, ArrayList<Integer> path){
        if(root == null) return;
        target -= root.val;
        path.add(root.val);
        rec(root.left,target,path);
        rec(root.right,target,path);
        if(root.left == null && root.right == null && target == 0){
            ArrayList<Integer> cur = new ArrayList(path);//可以直接用其作为参数创建
            res.add(cur);
        }
        path.remove(path.size()-1);
    }
}
```

#### 20.[剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

```
请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null
```

```
Tips: 1.复制原节点，放在该节点的后面,串起来；2.赋值新节点的random； 3.拆分原链表和新链表
```

```java
class Solution {
    public Node copyRandomList(Node head) {
       if(head == null) return head;
       Node dumb = new Node(-1);//定义辅助，哑节点
       Node cur = head;
       Node next;
       while(cur != null){//复制结点
           Node newN = new Node(cur.val);
           next = cur.next;
           cur.next = newN;
           newN.next = next;
           cur = next;
       }
       cur = head;
       while(cur != null){ //复制random
           if(cur.random != null){
               cur.next.random = cur.random.next;
           }
           cur = cur.next.next;
       } 
       cur = head;
       dumb.next = head.next;
       while(cur != null){//拆分
           next = cur.next;
           cur.next = next.next;
           cur = cur.next;
           if(cur != null){ //注意判空，如果next已经为原链表尾部，则新链表也是尾部，无.next字段
            next.next = cur.next;
           }
       }
       return dumb.next;
    }
}
```

#### 21.[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

```
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向
```

```
Tips:二叉搜索树左小右大，根节点必然是其右孩子(无右孩子则是其父亲)的前驱，故按中序遍历，用pre记录当前前驱节点，将当前节点和pre的互指即可，再进入右子树递归前，将pre更新为当前节点即可，需注意首尾节点的特例判断。
```

```java
class Solution {
    Node pre = null;
    Node head = null;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        rec(root);
        head.left = pre; //首尾节点互指
        pre.right = head;
        return head;  
    }

    public void rec(Node root){
        if(root == null) return;
        rec(root.left);
        if(pre == null){//首节点无前驱，需记录
            head = root;
        }
        else{
            root.left = pre;
            pre.right = root;
        }
        pre = root;
        rec(root.right);
    }
}
```

#### 22.[剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

```
输入一个字符串，打印出该字符串中字符的所有排列
```

```java
class Solution {
    ArrayList<String> res = new ArrayList();
    StringBuilder cur = new StringBuilder();//用SB而不要用字符串对象来加字符
    public String[] permutation(String s) {
        char[] c = s.toCharArray();
        Arrays.sort(c);//排序，可以避免产生重复排列
        allPermutation(c,c.length);
        return res.toArray(new String[res.size()]);
    }

    public void allPermutation(char[] c,int k){
        if(k == 0){//用个数来做出口
            res.add(cur.toString());
        }
        for(int i=0; i < c.length; i++){
            char tmp = c[i];
            if(tmp != '.'){
                if(i > 0 && c[i-1] == tmp) continue;//避免相同元素的等价性导致重复排列
                c[i] = '.';
                cur.append(tmp);
                allPermutation(c,k-1);
                c[i] = tmp;
                cur.deleteCharAt(cur.length()-1);
            }
        }
    }
}
```

#### 23.[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

```
剑指 Offer 39. 数组中出现次数超过一半的数字
//不同元素互相抵消，相同元素累加
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        int num = nums[0];
        int cnt = 1;
        for(int i = 1; i < nums.length; i++){
            if(cnt == 0){
                cnt = 1;
                num = nums[i];
                continue;
            }
            if(num != nums[i]) cnt--;
            else cnt++;
        }  
        return num; 
    }
}
```

#### 24.[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4
```

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if(k == 0) return new int[0];
        if(k >= arr.length) return arr;
        int s = 0, e = arr.length-1;
        quickSort(arr,s,e,k);//快排变形
        int[] res = new int[k];
        for(int i=0; i < k; i++){
            res[i] = arr[i];
        }
        return res;
    }

    public void quickSort(int[] arr,int s,int e,int k){
        if(s >= e) return;
        int p = patipation(arr, s, e);//判断分界点位置
        if(p == k-1) return;
        else if(p > k-1) quickSort(arr,s,p-1,k);//注意参数k不变
        else quickSort(arr,p+1,e,k);
        return;
    }

    public int patipation(int[] arr, int s, int e){
        int pivot = arr[s];
        int i = s, j = e;
        while(i < j){
            while(i < j && arr[j] >= pivot){//右侧先开始寻找
                j--;
            }
            while(i < j && arr[i] <= pivot){//左侧
                i++;
            }
            int tmp = arr[j];
            arr[j] = arr[i];
            arr[i] = tmp; 
        }
        arr[s] = arr[i];
        arr[i] = pivot;
        return i;
    }
}
```

#### 25.[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

```
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值
```

```java
//区间(子序列、子串)最值问题，一般考虑临界迭代或者双指针或dp
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            if(sum > max) max = sum;
            if(sum < 0)sum = 0;
        }
        return max;
    }
}
```

#### 26.[剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个
```

```java
//字符串拼接比较，按字典序小的决定单词顺序
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++){
             strs[i] = String.valueOf(nums[i]);
        }
        quickSort(0,nums.length-1,strs);
        StringBuilder res = new StringBuilder();
        for(int i=0; i < strs.length; i++){
            res.append(strs[i]);
        }
        return res.toString();
    }

    public void quickSort(int s, int e,String[] strs){
        if(s >= e) return;
        int p = partition(s,e,strs);
        quickSort(s,p-1,strs);
        quickSort(p+1,e,strs);
    }

    public int partition(int s, int e,String[] strs){
        int l = s, r = e;
        String pivot = strs[s];
        while(l < r){
            while(l < r ){
                if((strs[r]+pivot).compareTo(strs[l]+pivot) < 0) break;
                r--;
            } 
            while(l < r ){
                if((strs[l]+pivot).compareTo(strs[r]+pivot) < 0) break;
                l++;
            } 
            strs[s] = strs[r];
            strs[r] = strs[l];
            strs[l] = strs[s];
        }
        strs[s] = strs[l];
        strs[l] = pivot;
        return l;
    }
}
```

#### 27.[剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

```
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法
```

```java
//青蛙跳台阶变形：注意判断条件和滚动数组使用，用当前和前一个数字大小，不要用前一个和前前一个；
class Solution {
    public int translateNum(int num) {
        String str = String.valueOf(num);
        if(str.length() < 2) return 1;
        int a = 1; // p:-1
        int b = 1; // p: 0
        for(int i =1; i < str.length(); i++){
            int c = b; //i-1
            if(str.substring(i-1,i+1).compareTo("10")>= 0 && 
                    str.substring(i-1,i+1).compareTo("25") <=0)
                c += a; //i-2
            a = b;
            b = c;
        }
        return b; 
    }
}
```

#### 28.[剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

```
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
```

```java
class Solution {
    int[][] dp;
    public int maxValue(int[][] grid) {
        dp = new int[grid.length][grid[0].length];
        dp[0][0] = grid[0][0];
        for(int i =1; i < grid[0].length; i++){ //注意初始化
            dp[0][i] = dp[0][i-1] + grid[0][i];
        }
        for(int j=1; j < grid.length; j++){ //注意初始化
            dp[j][0] = dp[j-1][0] + grid[j][0];
        }
        for(int i=1; i < grid.length; i++){
            for(int j=1; j < grid[0].length; j++){
                dp[i][j] = dp[i-1][j] > dp[i][j-1] ? dp[i-1][j] : dp[i][j-1];
                dp[i][j] += grid[i][j];
            }
        }
        return dp[grid.length-1][grid[0].length-1];
    }
}
```

#### 29.[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() == 0) return 0;
        char[] c = s.toCharArray();
        HashMap<Character,Integer> m = new HashMap();
        int l = 0; //窗口左
        int len = 0;
        for(int i = 0; i < c.length; i++){
            char cur = c[i];
            if(m.containsKey(cur) && m.get(cur) >= l) {//窗口右，注意窗口左侧的重复不算
                int gap = i-l;//窗口长度
                if(gap > len) len = gap;
                l = m.get(cur)+1;
            }
            m.put(cur,i);
        }
        if(c.length-l > len) len = c.length - l;//注意原串本身无重复
        return len;
    }
}
```

#### 30.[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数
```

```java
class Solution {
    int res = 0;
    public int reversePairs(int[] nums) {
        mergeSort(nums,0,nums.length-1);
        return res;
    }
	
    //归并排序
    public void mergeSort(int[] nums, int s, int e){
        if(s >= e) return;
        int mid = (s+e)/2;
        mergeSort(nums,s,mid);
        mergeSort(nums,mid+1,e);
        int i = s;
        int j = mid+1;
        int[] temp = new int[e-s+1];
        int co = 0;
        //合并排序序列
        while(i <= mid && j <= e){
            if(nums[i] <= nums[j]) {
                temp[co++] = nums[i];
                i++;
            }
            else{
                res += mid-i+1;//注意此时的逆序对数应该要加上其后的所有数字
                temp[co++] = nums[j];
                j++;
            }
        }
        while(i <= mid){
            temp[co++] = nums[i];
            i++;
        }
        while(j <= e){
            temp[co++] = nums[j];
            j++;
        }
        for(int t = s; t <=e; t++){
            nums[t] = temp[t-s];
        }
    }
}
```

#### 31.[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

```
输入两个链表，找出它们的第一个公共节点
```

```java
//x+z+y = y+z+x
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null) return null;
        ListNode cur1 = headA;
        ListNode cur2 = headB;
        while(cur1 != cur2){
            if(cur1 == null){//要么走
                cur1 = headB;
            }
            else{//要么切换
                cur1 = cur1.next;
            }
            if(cur2 == null) {
                cur2 = headA;
            }
            else{
                cur2 = cur2.next;
            }
        }
        return cur1;
    }
}
```

#### 32.[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

```
统计一个数字在排序数组中出现的次数
```

```java
//firstGE lastGE
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0) return 0;
        return  countSearch(nums,target);
    }

    public int countSearch(int[] nums,int target){
        int[] res = new int[2];
        int l=0, h = nums.length-1;
        int mid;
        while(l < h){
            mid = l+(h-l)/2; //注意这里要用l+(h-l)/2否则有些情况，(l+h)/2 =h,一直h死循环;
            if(nums[mid] < target) l = mid +1;
            else h = mid;
        }
        if(nums[l] != target) return 0;//注意检验退出条件
        res[0] = l;
        l = 0;
        h =nums.length-1;
        while(l < h){
            mid = l+(h-l+1)/2;xu
            if(nums[mid] > target) h = mid -1;
            else l = mid;
        }
        res[1] = l;
        return res[1] -res[0]+1;
    }
}
```

#### 33.[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字
```

```java
class Solution {
    public int missingNumber(int[] nums) {
        int l = 0, h = nums.length-1;
        int mid;
        while(l < h){
            mid = l + (h-l)/2;
            if(nums[mid] == mid) l = mid+1;
            else h = mid;
        }
        if(nums[l] == l) return l+1; //注意检验退出条件
        return nums[l]-1;
    }
}
```

#### 34.[剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
```

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix.length == 0  || matrix[0].length == 0) return false;
        int r = 0, c = matrix[0].length-1;
        while(r < matrix.length && c >= 0){
            if(matrix[r][c] > target) {
                c--;
            }
            else if(matrix[r][c] < target){
                r++;
            }
            else
                return true;
        }
        return false;
    }
}
```

#### 35.[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```
给定一棵二叉搜索树，请找出其中第k大的节点的值
```

```java
class Solution {
    int cnt = 0;
    int res = 0;
    public int kthLargest(TreeNode root, int k) {
        cnt = k;
        reverseOrder(root);
        return res;
    }

    public void reverseOrder(TreeNode root) {
        if(root == null || cnt == 0)return;
        reverseOrder(root.right);
        if(cnt == 1){
            res = root.val;
        }
        cnt--;
        reverseOrder(root.left);
    }
}
```

#### 36.[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度
```

```java
class Solution {
    public int maxDepth(TreeNode root) {
        int dep = 0;
        if(root == null) return 0;
        dep += 1;
        int left_dep = maxDepth(root.left);
        int right_dep = maxDepth(root.right);
        if(left_dep > right_dep) dep += left_dep;
        else dep += right_dep;
        return dep;
    }
}
```

#### 37.[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

```
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树
```

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        int left_dep = rec(root.left);
        int right_dep = rec(root.right);
        if(left_dep == -1 || right_dep == -1) return false;
        if(left_dep - right_dep > 1 || left_dep - right_dep < -1) return false;
        return true;
    }
    public int rec(TreeNode root) {
        int dep = 0;
        if(root == null) return dep;
        dep  = 1;
        int left_dep = rec(root.left);
        int right_dep = rec(root.right);
        if(left_dep == -1 || right_dep == -1) return -1; //子树不合法直接标记
        if(left_dep - right_dep > 1 || left_dep - right_dep < -1) return -1;
        return left_dep > right_dep ? dep + left_dep : dep + right_dep;//合法才返回深度
    }
}
```

#### 38.[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)
```

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int xor_sum = 0;
        for(int i = 0; i < nums.length ; i++){
            xor_sum ^= nums[i];
        }
        int ubit = 1;
        while((xor_sum & ubit)== 0){//检验首个为1的位，即不一样的二进制位(异或为1)
            ubit <<= 1;
        }
        int x = 0, y = 0;
        for(int i = 0; i < nums.length ; i++){
            if((ubit & nums[i]) == 0) x ^= nums[i];//分组异或
            else y ^= nums[i];
        }
        return new int[]{x,y};
    }
}
```

#### 39.[剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

```
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字
```

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] cnt = new int[31];
        int res = 0;
        for(int i =0; i < nums.length; i++){
            for(int j = 0; j < 31; j++){
                cnt[j] += nums[i] & 1;//求每个bit位中1出现的总次数
                nums[i] >>= 1;
            }
        }
        int b = 1;
        for(int i=0; i < 31; i++){
            res += (cnt[i]%3)*b;
            b <<= 1;
        }
        return res;
    }
}
```

#### 40.[剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

```
输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可；方法1：HashMap存已经遍历的数. 2: i,j双指针对撞
```

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> m = new HashMap();
        int[] res = new int[2];
        for(int i =0 ; i < nums.length; i++){
            if(m.containsKey(target-nums[i])){
                res[0] = nums[i];
                res[1] = target - nums[i];
                break;
            }
            else{
                m.put(nums[i],1);
            }
        }
        return res;
    }
}
```

#### 41.[剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

```
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数. 利用前缀和来求，sum-target如果在之前得前缀中存在，即是一个合法序列
```

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int[] prefix = new int[target+1];
        HashMap<Integer,Integer> m = new HashMap();
        ArrayList<int[]> a = new ArrayList();
        int sum = 0;
        int p = 0;
        for(int i=1; i < target; i++){
            m.put(sum,i-1);
            sum += i;
            if( m.get(sum - target) != null){
                p =  m.get(sum - target);
                a.add(new int[]{p+1,i});
            }
        }
        int[][] res = new int[a.size()][];
        for(int i = 0; i < a.size(); i++){
            int[] tmp  = a.get(i);
            int size = tmp[1]-tmp[0]+1;
            res[i] = new int[size];
            for(int j = 0; j < size; j++){
                res[i][j] = tmp[0] + j;
            }
        }
        return res;
    }
}
```

#### 42.[剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

```
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"
```

```java
class Solution {
    public String reverseWords(String s) {
        s.trim();//可以利用trim来去掉首尾空格降低逻辑复杂度
        char[] c =  s.toCharArray();
        StringBuilder res = new StringBuilder(); 
        int j = c.length-1;
        int i = c.length-1;
        while(i >= 0){
            while(i >= 0 && c[i] != ' '){
                i--;
            }
            res.append(s.substring(i+1,j+1));//可以利用substring来减少reverse
            res.append(" ");
            while(i >= 0 && c[i] == ' '){
                i--;
            }
            j = i;
        }
        return res.toString().trim();//可以利用trim来去掉首尾空格降低逻辑复杂度
    }
}
```

#### 43.[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"
```

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        char[] c = s.toCharArray();
        StringBuilder res = new StringBuilder();
        for(int i = n; i < c.length; i++){
            res.append(c[i]);
        }
        for(int i= 0; i < n; i++){
            res.append(c[i]);
        }
        return res.toString();
    }
}
```

#### 44.[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

```
给定一个数组nums和滑动窗口的大小k，请找出所有滑动窗口里的最大值
Tips:保持窗口单调递减队列
```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0 || k == 0) return new int[0];
        Deque<Integer> deque = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];
        for(int j = 0, i = 1 - k; j < nums.length; i++, j++) {
            // 删除 deque 中对应的 nums[i-1]
            if(i > 0 && deque.peekFirst() == nums[i - 1])//未形成窗口前是不用删除队首对应元素
                deque.removeFirst();
            // 保持 deque 递减
            while(!deque.isEmpty() && deque.peekLast() < nums[j])
                deque.removeLast();
            deque.addLast(nums[j]);
            // 记录窗口最大值
            if(i >= 0)
                res[i] = deque.peekFirst();
        }
        return res;
    }
}
```

#### 45.[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

```
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1);若队列为空，pop_front 和 max_value 需要返回 -1
Tips:单调递减队列
```

```java
class MaxQueue {
    LinkedList<Integer> q;
    LinkedList<Integer> max_q;
    public MaxQueue() {
        q =  new LinkedList();
        max_q = new LinkedList();
    }
    
    public int max_value() {
        return max_q.size() > 0 ? max_q.peekFirst(): -1;
    }
    
    public void push_back(int value) {
        q.offer(value);
        while(max_q.size()>0 && max_q.peekLast() < value) max_q.removeLast();
        max_q.offerLast(value);
    }
    
    public int pop_front() {
        if(q.size() == 0) return -1;
        if(max_q.peekFirst().equals(q.peek())) max_q.removeFirst();
        return q.poll();
    }
}
```

#### 46.[剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

```
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率
```

```java
class Solution {
    public double[] dicesProbability(int n) {
        int size = n*5+1;
        double[] res = new double[size];
        double[][] dp  = new double[n+1][n*6+1];
        dp[0][0] = 1.0;
        for(int i= 1; i <= n; i++){
            for(int j = i; j <= 6*i; j++){//注意取值范围
                for(int t = 1; t <=6; t++){
                    if(j-t >= 0)
                        dp[i][j] += dp[i-1][j-t]*1.0/6;
                }
            }
        }
        for(int i=0; i < size; i++){
            res[i] = dp[n][i+n];
        }
        return res;
    }
}
```

#### 47.[剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```
从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14
```

```java
class Solution {
    public boolean isStraight(int[] nums) {
        HashMap<Integer,Integer> m = new HashMap();
        int min = nums[0];
        int max = nums[0];
        for(int i=0; i < nums.length; i++){
            if(nums[i] == 0) {
                continue;
            }
            if(m.containsKey(nums[i])) return false;//特例，有重复的牌
            if(min > nums[i] || min == 0) min = nums[i];
            if(max < nums[i] || max == 0) max = nums[i];
            m.put(nums[i],1);
        }
        if(max - min <= 4) return true;//只需判断牌中除大小王外的最大差值是否超过4即可
        return false;
    }
}
```

#### 48.[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字
Tips:圆圈删除相当于循环链表，循环链表求模相当于多个原链表复制后进行连接的遍历，因此对于每一轮来说我们相当于从链首在无限长度的复制链表中走m个元素，然后删除原链表中删除对应元素，进行下一轮；
因此，我们可以知道每轮中首元素(下标0)应该是上一轮中前面有m个元素，即h_上 =  m % i_上;我们要求最后一个数字，因此我们可以先算出这个数字在每一轮中距离该轮首元素的距离，即其在该轮的下标p，然后其在上一轮中前面就有m+p个元素，即p_上 =(p+m)%i_上;
```

```java
class Solution {
    public int lastRemaining(int n, int m) {
        int p = 0; //最后剩下的数字，在数组中下标为0
        for(int i = 2; i <= n; i++){
            p = (p + m) % i; //新数组首位的下标，证明在上一轮中在其前面有m个数字
        }
        return p;
    }
}
```

#### 49.[剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

```
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length <= 1) return 0;
        int min = prices[0];
        int gap = 0;
        for(int i =1 ; i  < prices.length; i++){
            if(prices[i] - min > gap) gap = prices[i] - min;
            if(prices[i] < min) min = prices[i];
        }
        return gap;
    }
}
```

#### 50.[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
Tips:二叉搜索树中lca目标节点必然在左右子树中,因此可以用当前节点值来进行左或右子树的选择，以减少正面选择时复杂逻辑判断
```

```java
class Solution {
    TreeNode res  = null;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        rec(root,p,q);
        return res;
    }

    public void rec(TreeNode root, TreeNode p, TreeNode q){
        if(root == null) return;
        if(root.val > p.val && root.val > q.val){
            rec(root.left,p,q);
            return;
        }
        if(root.val < p.val && root.val < q.val){
            rec(root.right,p,q);
            return;
        }
        res = root;
    }
}
```

#### 51.[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先
```

```java
class Solution {
    TreeNode res  = null;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        rec(root,p,q);
        return res;
    }

    public int rec(TreeNode root, TreeNode p, TreeNode q){
         if(root == null || res != null) return 0;//lca找到则直接返回
         int l = rec(root.left,p,q);
         int r = rec(root.right,p,q);
         int v = root == p || root == q ? 1 : 0;//节点等于目标值为1
         if(l+r == 2) {//目标值在左右子树
             res = root;
             return 0;
         }
         if(l+r+v == 2) {//本身也为目标值
             res = root;
             return 0;
         }
         return l+r+v;
    }
}
```

#### 52.[面试题19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

```
请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配
Tips:抓住匹配串最后一个字符必须匹配即可
```

```java
class Solution {
    public boolean isMatch(String s, String p) {
        char[] cS = s.toCharArray();
        char[] cP = p.toCharArray();
        int[][] dp = new int[cS.length+1][cP.length+1];
        dp[0][0] = 1;
        for(int j = 1; j < cP.length; j +=2){ //初始化，*作为炸弹
            dp[0][j+1] = cP[j] == '*' ? dp[0][j-1] : 0;
        }
        for(int i = 0; i < cS.length; i++){
            for(int j = 0; j< cP.length; j++){
                if(cP[j] == '.' || cP[j] == cS[i]){ //字符相等，两者都退
                    dp[i+1][j+1]  = dp[i][j];
                }
                else if(cP[j] == '*'){
                    if( cP[j-1] == '.' || cP[j-1] == cS[i]){
                        dp[i+1][j+1] |= dp[i][j+1];//*本次出一个匹配字符，前面匹配可继续复用
                    }
                    dp[i+1][j+1] |= dp[i+1][j-1];//*做炸弹
                }
                else{
                    dp[i+1][j+1] = 0;//最后一个字符无法匹配
                }
            }
        }
        return dp[cS.length][cP.length] > 0 ? true : false;
    }
}
```

#### 53.[面试题50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

```
在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母
```

```java
class Solution {
    public char firstUniqChar(String s) {
        char res = ' ';
        if(s.length() == 0) return ' ';
        char[] c = s.toCharArray();
        HashMap<Character,Integer> m = new HashMap();
        for(int i=0; i < c.length; i++){
            if(!m.containsKey(c[i])){
                m.put(c[i],1);
            }
            else{
                m.put(c[i],m.get(c[i])+1);
            }
        }
        for(int i=0; i < c.length; i++){
            if(m.get(c[i])==1){
                res =c[i];
                break;
            }
        }
        return res;
    }
}
```

